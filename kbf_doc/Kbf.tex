\documentclass[times, utf8, seminar, numeric]{fer}
\usepackage{booktabs}
\usepackage{tabu, multirow}
\usepackage{tabularx}
% \usepackage{float}
\usepackage{array}
\usepackage{tabularx}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
% \usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
% \usepackage[croatian]{babel}

\renewcommand{\labelitemi}{$\circ$}
\makeatletter
\renewcommand{\ALG@name}{Algoritam}
\makeatother

\begin{document}
% \lstset{language=c}

% TODO: Navedite naslov rada.
\title{Poboljšanje Bloom filtra korištenjem k-mer Bloom filtra}

% TODO: Navedite vaše ime i prezime.
\author{Magdalena Halusek i Katarina Prgeša}

% TODO: Navedite ime i prezime mentora.
\voditelj{Mirjana Domazet-Lošo}

\maketitle

\tableofcontents

\chapter{Uvod}
Bloom filtar je podatkovna struktura koja memorijski efikasno određuje nalazi li
se traženi element u određenom setu ili ne \cite{bloom_filter}. Glavni nedostatak
Bloom filtra je što odgovor na upit postojanja elementa u setu može biti ili da
se definitivno ne nalazi u setu ili da se možda nalazi. Drugim riječima, Bloom
filtar ne može dati pozitivan odgovor s potpunom sigurnošću. Razlog tome je što
se za unošenje elemenata u Bloom filtar i za njihovo traženje koriste hash
funkcije. Prilikom unošenja i traženja elemenata, hash funkcije vraćaju indekse
koji se kod unošenja koriste za postavljanje '1' na pozicijama koje
odgovaraju dobivenim indeksima. Kod provjere postojanja elementa u nizu, gledaju
se vrijednosti na dobivenim indeksima. Ako je na jednom od dobivenih indeksa
postavljena '0', tada Bloom filtar vraća negativni odgovor na postojanje elementa
u nizu, a ako je na svakom od indeksa vrijednost '1', tada se u nizu nalazi
traženi element ili neki drugi element koji bi dao istu kombinaciju indeksa.
Mjera kojom se izražava nesigurnost pozitivnog odgovora koji daje Bloom filtar
naziva se lažno-pozitivna mjera te će se u nastavku koristiti kratica FPR koja
dolazi od engleskog naziva (\textit{False Positive Rate}).
U nastavku će biti prikazano kako smanjiti FPR koji daje Bloom filtar korištenjem
k-mera, gdje k-mer označava jedan niz od k elemenata (A, C, G i T) \cite{kmer}.
Pošto se u bioinformatici radi s velikom količinom podataka, u interesu je
smanjiti memorijsko opterećenje te će u nastavku biti opisano i kako se korištenjem
k-mera mogu poboljšati memorijske performase.

\chapter{Smanjenje FPR-a korištenjem k-mera}
Kod korištenja k-mera, ulazni niz se obrađuje na način da se od početka sekvence
uzme jedan podniz duljine k (jedan k-mer) i stavi se u Bloom filtar. Sljedeći
podniz se dobije na način da se od početka ulaznog niza pomakne za jedan znak
prema kraju niza i stavi se u Bloom filtar. Bloom filtar se tako puni sve dok se
ne dođe do kraja ulaznog niza.
Glavna ideja kod smanjenja FPR-a stoji iza činjenice da se u Bloom filtru nalaze
odabrani k-mer te k-mer koji mu neposredno prethodi i k-mer koji ga neposredno
slijedi \cite{kbf}. U daljnjem tekstu, k-mer koji neposredno prethodi nekom
drugom k-meru će se zvati lijevi susjed, a k-mer koji neposredno slijedi isti
k-mer će se zvati desni susjed. Dakle, kao dodatna provjera postojanje odabranog
k-mera u Bloom filtru svakako može poslužiti i provjera postojanja desnog ili
lijevog susjeda promatranog k-mera. Navedena provjera se može podijeliti na dva
pristupa:
\begin{itemize}
  \item{jednostrani k-mer Bloom filtar}
  \item{dvostrani k-mer Bloom filtar.}
\end{itemize}

\section{Jednostrani k-mer Bloom filtar}
Jednostrani k-mer Bloom filtar se temelji na provjeri koja mora rezultirati
pozitivnim odgovorom u barem 2 slučaja:
\begin{itemize}
  \item{promatrani k-mer se nalazi u Bloom filtru}
  \item{jedan od susjeda promatranog k-mera se nalazi u Bloom filtru}
\end{itemize}
Za potrebe navedene provjere, potrebno je rekonstruirati sve moguće susjede
promatranog k-mera te za svaki od njih posebno provjeriti njihovo pojavljivanje
u Bloom filtru. Lijevi susjedi se mogu dobiti dodavanjem jedne baze na početak
promatranog k-mera te oduzimanjem jedne baze koja se nalazi na posljednjem indeksu
promatranog k-mera. Desni susjedi se mogu dobiti oduzimanjem jedne baze na početku
promatranog k-mera i dodavanjem jedne baze na kraj k-mera.\\
\textit{Primjer 1.} Ako je odabran 8-mer, čija se prisutnost u Bloom filtru želi
provjeriti, AACCTTGG, njegovi lijevi susjedi bi bili:
\begin{itemize}
  \item{AAACCTTG}
  \item{CAACCTTG}
  \item{GAACCTTG}
  \item{TAACCTTG}
\end{itemize}
Desni susjedi navedenog 8-mera bi bili:
\begin{itemize}
  \item{ACCTTGGA}
  \item{ACCTTGGC}
  \item{ACCTTGGG}
  \item{ACCTTGGT}
\end{itemize}
Opisani postupak se može prikazati algoritmom \ref{one_alg}.

\begin{algorithm}[H]
  \caption{Jednostrani k-mer Bloom filtar \cite{kbf}}
  \label{one_alg}
  \begin{algorithmic}[1]
    \Function{One\_sided\_kBF\_contains}{$query$}
      \If{\Call{BF.contains}{$query$}}
        \State{\textbf{return} \Call{contains\_set}{neighbour\_set($query$)}}
      \EndIf
      \State{\textbf{return false}}
    \EndFunction\\
    \Function{contains\_set}{$set$}
      \For{$kmer \in set$}
        \If{\Call{BF.contains}{$kmer$}}
          \State{\textbf{return true}}
        \EndIf
      \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\section{Dvostrani k-mer Bloom filtar}
Za razliku od jednostranog k-mer Bloom filtra, dvostrani k-mer Bloom filtar mora
rezultirati pozitivnim odgovorom u 3 slučaja:
\begin{itemize}
  \item{promatrani k-mer se nalazi u Bloom filtru}
  \item{lijevi susjed k-mera se nalazi u Bloom filtru}
  \item{desni susjed k-mera se nalazi u Bloom filtru}
\end{itemize}
Pošto kod dvostranog k-mer Bloom filtra oba susjeda promatranog k-mera moraju biti
prisutni, dvostrani k-mer Bloom filtar ima jednu iznimku, a to je u slučaju kada
se promatrani k-mer nalazi na rubu sekvence. Takvi k-meri se nazivaju rubni k-meri
te moraju biti spremljeni zasebno. Ako se radi o iznimci, dvostrani k-mer Bloom
filtar mora dati pozitivne odgovore u sljedeća 3 slučaja:
\begin{itemize}
  \item{promatrani k-mer se nalazi u Bloom filtru}
  \item{jedan od susjeda se nalazi u Bloom filtru}
  \item{promatrani k-mer je rubni k-mer}
\end{itemize}
Opisani postupak se može prikazati algoritmom \ref{two_alg}.

\begin{algorithm}[H]
  \caption{Dvostrani k-mer Bloom filtar \cite{kbf}}
  \label{two_alg}
  \begin{algorithmic}[1]
    \Function{Two\_sided\_kBF\_contains}{$query$}
      \State $contains\_left \gets$ \Call{contains\_set}{left\_neighbour\_set($query$)}
      \State $contains\_right \gets$ \Call{contains\_set}{right\_neighbour\_set($query$)}
      \If{$contains\_left == 1$ \textbf{and} $contains\_right == 1$}
        \State{\textbf{return true}}
      \EndIf
      \If{$contains\_left == 1$ \textbf{or} $contains\_right == 1$}
        \If{\Call{edge\_k-mer\_set.contains}{$query$}}
          \State{\textbf{return true}}
        \EndIf
      \EndIf
      \State{\textbf{return false}}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\chapter{Princip preklapanja sekvenci za smanjenje k-mer setova}
Korištenje k-mera u obradi velike količine podataka može biti memorijski zahtjevno
te se zbog toga radi na smanjenju broja k-mera koji moraju biti spremljeni u
Bloom filtar. Jedan od načina na koji se to može postići je korištenje svojstva
preklapanja sekvenci.\\
Prije objašnjenja navedenog načina, potrebno je definirati sljedeće oznake:
\begin{itemize}
  \item{{$U$} - set k-mera koje treba pohraniti}
  \item{{$k$} - jedan k-mer iz {$U$}}
  \item{{$L_k$} - set k-mera koji se u {$U$} nalaze prije {$k$}}
  \item{{$R_k$} - set k-mera koji se u {$U$} nalaze nakon {$k$}}
\end{itemize}
Smanjenje broja k-mera koje treba pohraniti se postiže na način:\\
Ako sigurno postoji jedan k-mer u {$L_k$} i jedan k-mer u {$R_k$}, tada se može
potvrditi postojanje k-mera {$k$} iz prisutnosti {$v$} {$\in$} {$L_k$} i
{$w$} {$\in$} {$R_k$}, bez potrebe za pohranom {$k$}.\\
\textit{Primjer 2.} Ako je promatrani 8-mer {$k$}~=~AACCTTGG te njegovi susjedi
{$v$}~=~TAACCTTG i {$w$}~=~ACCTTGGA, tada se do željenog k-mera {$k$} može doći
kombinacijom {$v$} i {$w$}.
Kako bi se stvarno moglo kombinacijom {$v$} i {$w$} doći do {$k$} postoji jedan
uvjet za koji je potrebno definirati dodatne oznake:
\begin{itemize}
  \item{{$P_{vk}$} - skup pozicija lijevih susjeda {$v$}}
  \item{{$A_{kw}$} - skup pozicija desnih susjeda {$w$}}
  \item{{$S_{k}(v,w)$} - udaljenost između odgovarajućih pozicija lijevih i
    desnih susjeda}
  \item{{$s$} - broj k-merova koje je dopušteno preskočiti}
\end{itemize}
$S_{k}(v,w)$ je opisan s \ref{S_def}.
\begin{equation}
  \label{S_def}
  S_k(v,w) = \{i_w - i_v~|~i_v \in P_{vk}, i_w \in A_{kw}\}
\end{equation}
Definiranjem potrebnih oznaka uvjet se može opisati s \ref{distance}.
\begin{equation}
  \label{distance}
  min(S_k(v,w)) \leq s
\end{equation}
Navedeni uvjet se može rastaviti na dva problema.\\
\textit{Problem 1: Opušteni problem smanjenja k-mer setova (algoritam \ref{rel_alg})}\nopagebreak\\
Iz zadanog skupa k-mera {$U$} treba pronaći mali podskup {$K \subset U$} za sve
{$k \in U$}, bilo da je {$k \in K$} ili postoje {$v \in K \cap L_k$} i
{$w \in K \cap R_k$} za koje vrijedi {$min(S_k(v,w)) \leq s$}.\\
\textit{Problem 2: Strogi problem smanjenja k-mer setova (algoritam \ref{str_alg})}\nopagebreak\\
Iz zadanog skupa k-mera {$U$} treba pronaći mali podskup {$K \subset U$} za sve
{$k \in U$}, bilo da je {$k \in K$} ili postoje {$v \in K \cap L_k$} i
{$w \in K \cap R_k$} za koje vrijedi {$min(S_k(v,w)) = s$}.\\

\begin{algorithm}[H]
  \caption{Opušteni problem smanjenja k-mer setova \cite{kbf}}
  \label{rel_alg}
  \algnewcommand\algorithmicto{\textbf{to}}
  \begin{algorithmic}[1]
    \Function{Decide\_present}{$query, contains\_left, contains\_right$}
      \If{$contains\_left == 1$ \textbf{and} $contains\_right == 1$}
        \State{\textbf{return true}}
      \EndIf
      \If{$contains\_left == 1$ \textbf{or} $contains\_right == 1$}
        \If{\Call{edge\_k-mer\_set.contains}{$query$}}
          \State{\textbf{return true}}
        \EndIf
      \EndIf
      \State{\textbf{return false}}
    \EndFunction\\
    \Function{relaxed\_contains\_neighbours}{$query, l\_dist, r\_dist$}
      \State $contains\_left \gets$ \Call{contains\_set}{$\bigcup\limits_{i \le l\_dist}$s\_distant\_left\_neighbour\_set($query, i$)}
      \State $contains\_right \gets$ \Call{contains\_set}{$\bigcup\limits_{i \le r\_dist}$s\_distant\_right\_neighbour\_set($query, i$)}
      \State \textbf{return} \Call{Decide\_present}{$query, contains\_left, contains\_right$}
    \EndFunction\\
    \Function{relaxed\_contains}{$query, s$}
      \If{\Call{BF.contains}{$query$}}
        \If{\Call{relaxed\_contains\_neighbours}{$query, s, s$}}
          \State{\textbf{return true}}
        \EndIf
      \Else
        \For{$i \gets 0~\algorithmicto\ s-1$}
          \If{\Call{relaxed\_contains\_neighbours}{$query, i, s - (i + 1)$}}
            \State{\textbf{return true}}
          \EndIf
        \EndFor
      \EndIf
      \State{\textbf{return false}}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Strogi problem smanjenja k-mer setova \cite{kbf}}
  \label{str_alg}
  \algnewcommand\algorithmicto{\textbf{to}}
  \begin{algorithmic}[1]
    \Function{strict\_contains\_neighbours}{$query, l\_dist, r\_dist$}
      \State $contains\_left \gets$ \Call{contains\_set}{s\_distant\_left\_neighbour\_set($query, l\_dist$)}
      \State $contains\_right \gets$ \Call{contains\_set}{s\_distant\_right\_neighbour\_set($query, r\_dist$)}
      \State \textbf{return} \Call{Decide\_present}{$query, contains\_left, contains\_right$}
    \EndFunction\\
    \Function{strict\_contains}{$query, s$}
      \If{\Call{BF.contains}{$query$}}
        \If{\Call{strict\_contains\_neighbours}{$query, s, s$}}
          \State{\textbf{return true}}
        \EndIf
      \EndIf
      \For{$i \gets 0~\algorithmicto\ s-1$}
        \If{\Call{strict\_contains\_neighbours}{$query, i, s - (i + 1)$}}
          \State{\textbf{return true}}
        \EndIf
      \EndFor
      \State{\textbf{return false}}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Kao rješenja na navedene probleme navode se tri pristupa:
\begin{itemize}
  \item{\textit{Pristup 1: Pristup najboljeg podudaranja indeksa} - Podskup {$K$}
  se gradi pohlepno tako da se uzima svaki s-ti k-mer iz ulaznog niza {$U$} od točno
  određenog indeksa {$i_r$}. Indeks {$i_r$} se određuje tako da je najveće
  preklapanje k-mera s dosadašnjim podskupom {$K$}. Ulazni niz je dobiven
  očitavanjima i {$s$} je proizvoljan.}
  \item{\textit{Pristup 2: Pristup podudarajućeg seta} - Podskup {$K$}
  se gradi pohlepno tako da se za svaki k-mer iz ulaznog niza {$U$} zapamti
  podskup lijevih susjeda {$L_k$} i desnih susjeda {$R_k$} k-mera {$k$} te se u
  {$K$} pohrane k-meri koji se nalaze u najviše setova {$R_k$} i {$L_k$}.
  Ulazni niz je dobiven očitavanjima i {$s = 1$}.}
  \item{\textit{Pristup 3: Pristup jedinstvene sekvence} - Podskup {$K$} se gradi
  tako da se iz ulaznog niza uzme svaki s-ti k-mer počevši od nulte pozicije.
  Ovaj pristup se koristi kod slučaja gdje je ulazni niz poznat (cijeli genom) te
  je {$s$} proizvoljan.}
\end{itemize}

\chapter{Usporedba rezultata}
Rezultati prikazani u ovom poglavlju, dobiveni su testiranjem nad genomom
Pseudomonas aeruginosa. Prilikom implementacije jednostranog i dvostranog k-mer
Bloom filtra, ulazna datoteka se je parsirala tako da se iz datoteke čitala linija
po linija te se svaki k-mer stavljao u Bloom filtar. Kod dvostranog k-mer Bloom
filtra su se dodatno spremali i rubni k-meri u poseban Bloom filtar. Odabrani
parametri nad kojima se je testiralo su:
\begin{itemize}
  \item{$k = 20$}
  \item{$s = 1$}
\end{itemize}
Pošto je testiranje provedeno nas cijelim genomom, parsiranje ulazne datoteke za
slučaj smanjenja zauzeća memorije za Bloom filtar je izvedeno na način da se iz
ulaznog niza uzeo svaki s-ti k-mer, počevši od nultog indeksa.
Savaka implementacija se je testirala nad istim skupom podataka koji se sastoji
od milijun k-mera. Skup k-mera je dobiven tako da se iz ulazne datoteke nasumično
izabralo milijun k-mera i od njih se 3/4 mutiralo na način da se nasumično izabrala
jedna baza u pojedinom k-meru i zamijenila se s drugom nasumično izabranom bazom.

\begin{table}[H]
  \centering
  \caption{Vremensko izvođenje implementacija}
  \begin{tabular}{|| p{2.7cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} ||}
    \hline
    Skup podataka & 1-kBf[ms] & 2-kBf[ms] & HS[ms] & BF[ms]\\
    \hline\hline
    P. aeruginosa & & & &\\
    \hline
    E. coli & & & &\\
    \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \caption{Vremensko izvođenje implementacija autora prijedloga}
  \begin{tabular}{|| p{2.7cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} ||}
    \hline
    Skup podataka & 1-kBf[ms] & 2-kBf[ms] & HS[ms] & BF[ms]\\
    \hline\hline
    P. aeruginosa & & & &\\
    \hline
    E. coli & & & &\\
    \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \caption{Memorijsko zauzeće}
  \begin{tabular}{|| p{2.7cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} ||}
    \hline
    Skup podataka & 1-kBf[MB] & 2-kBf[MB] & HS[MB] & BF[MB]\\
    \hline\hline
    P. aeruginosa & & & &\\
    \hline
    E. coli & & & &\\
    \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \caption{Memorijsko zauzeće autora prijedloga}
  \begin{tabular}{|| p{2.7cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} ||}
    \hline
    Skup podataka & 1-kBf[MB] & 2-kBf[MB] & HS[ms] & BF[MB]\\
    \hline\hline
    P. aeruginosa & & & &\\
    \hline
    E. coli & & & &\\
    \hline
  \end{tabular}
\end{table}

\chapter{Zaključak}
Ovim radom se je pokazalo kako se korištenjem k-mera može postići bolji FPR, ali
i kako smanjiti memorijsko zauzeće koje je potrebno za Bloom filtar. Također,
pokazano je kako se odjednom ne može postići bolji FPR i manji Bloom filtar. Takav
rezultat je očekivan jer smanjenjem Bloom filtra se smanjuje količina indeksa
bit vektora koja se može koristiti. Time se bit vektor brže popuni jedinicama što
uzrokuje veću vjerojatnost preklapanja indeksa novih elemenata s elementima za koje
je potrebno provjeriti prisutnost u Bloom filtru.

% \bibliographystyle{unsrt}
% \bibliography{literatura}
\bibliography{literatura}
\bibliographystyle{fer}

\end{document}
